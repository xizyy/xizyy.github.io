{"pages":[{"title":"萌新一个","text":"","path":"about/index.html","date":"10-28","excerpt":""},{"title":"404","text":"","path":"404/index.html","date":"10-28","excerpt":""},{"title":"就这么几篇你还要分类？？？","text":"","path":"categories/index.html","date":"10-28","excerpt":""},{"title":"search","text":"","path":"search/index.html","date":"10-28","excerpt":""},{"title":"标签有什么好看的","text":"","path":"tags/index.html","date":"10-28","excerpt":""}],"posts":[{"title":"iptables浅析","text":"本文作为一个归纳总结，目的在与在完整看完后能初步掌握iptales的用法及部分原理与注意事项。一个使用iptables的SNAT来模拟路由器的实例因为实验条件有限，所以使用虚拟机进行模拟。先创建两个linux虚拟机，设为A，B。其中，A设置两个网卡，作为进行NAT的主机，eth0为192.168.1.101，eth0：2为192.168.2.101，网卡配置如下： B单网卡IP为192.168.2.102，网卡配置如下： 这个过程是为了模拟B为内网主机，A为网关路由器，真实路由器192.168.1.1为公网。接下来则要设置A的iptables完成路由转发功能，使B可以ping通真正的路由器192.168.1.1。 从下图可以很明显看到在没有设置iptables之前B是ping不通路由器的。 接下来用下列命令配置iptables：iptables -t nat -A POSTROUTING -j SNAT -s 192.168.2.0/24 --to-source 192.168.1.101这条命令将来自192.168.2.0网段的数据包的源地址在POSTROUTING转换成192.168.1.101,即我们模拟的公网地址。但是这条命令在重启后就会失效，如果要永久生效则需输入service iptables save来保存配置。还有一个值得注意的点，当把源地址改成192.168.1.101后，我们的真实路由器就收到数据包就会认为这是A发来的，从而把回应包发给A，那么怎么回到B呢？事实上做nat的时候,会有一个nf_conntrack表,里面记录了地址转换的条目,返回的时候查表然后发给内网用户。（关于iptalbes的较详细讲解在底下） 配置完之后可以看到B依然是ping不通的。 因为现在A收到B的发往192.168.1.1的数据包之后并不会进行转发，而是直接丢弃。所以需要开启数据包转发功能，这个功能因为安全问题大多数情况下都是默认关闭的。 这里使用了下列命令：echo 1 &gt; /proc/sys/net/ipv4/ip_forward这里有几个注意点。如果没有开启转发功能，文件内显示0,开启为1。之所以使用echo 1来重定向到文件中是因为proc是一个虚拟文件系统，并不存储在硬盘上，而是在内存中从下图可以看到，proc下的文件占用的空间是0如果使用vim会发生什么呢 可以看到，当尝试使用vim进行修改时是修改不了的，因为这不是一个真实存在硬盘上的文件。只能使用重定向修改内存里的数据。 而且这个配置将在重启后还原，因为保存在内存中的数据并不会在重启后还存在。 如过想要长久保持转发功能的话需要修改默认配置vim /etc/sysctl.conf进入sysctl.conf将ip_forward改为1,如下图： 接下来可以看到已经B已经可以ping通了： iptables介绍iptables是linux下的包过滤型防火墙。拥有四个表： filter:包过滤功能 nat：NAT功能 mangle：包修改功能 raw：优先级最高，设置raw时一般是为了不再让iptables做数据包的链接跟踪处理，提高性能 五个链： PREROUTING:数据包进入路由表之前 INPUT:通过路由表后目的地为本机(如本机应用程序接收的数据包) FORWARDING:通过路由表后，目的地不为本机（不经过本机的应用层） OUTPUT:由本机产生，向外转发（如由本机的应用层产生） POSTROUTIONG:发送到网卡接口之前。 如下图： 表和链的对应关系： filter：INPUT ，FORWARD ，OUTPUT nat：PREROUTING ，OUTPUT ，POSTROUTING mangle则是5个链都可以做：PREROUTING，INPUT，FORWARD，OUTPUT，POSTROUTING raw:PREROUTING , OUTPUT 4个表的优先级由高到低的顺序为:raw–&gt;mangle–&gt;nat–&gt;filter 注意：规则的次序非常关键，检查规则的时候，是按照从上往下的方式进行检查的。 参数： -A 追加规则–&gt;iptables -A INPUT-D 删除规则–&gt;iptables -D INPUT 1(编号)-R 修改规则–&gt;iptables -R INPUT 1 -s 192.168.12.0 -j DROP 取代现行规则，顺序不变(1是位置)-I 插入规则–&gt;iptables -I INPUT 1 –dport 80 -j ACCEPT 插入一条规则，原本位置上的规则将会往后移动一个顺位-L 查看规则–&gt;iptables -L INPUT 列出规则链中的所有规则-N 新的规则–&gt;iptables -N allowed 定义新的规则 -p 协议 例：iptables -A INPUT -p tcp-s源地址 例：iptables -A INPUT -s 192.168.1.1-d目的地址 例：iptables -A INPUT -d 192.168.12.1-sport源端口 例:iptables -A INPUT -p tcp –sport 22-dport目的端口 例:iptables -A INPUT -p tcp –dport 22-i指定入口网卡 例:iptables -A INPUT -i eth0-o指定出口网卡 例:iptables -A FORWARD -o eth0 -j 指定要进行的处理动作常用的ACTION：DROP：丢弃REJECT：明示拒绝ACCEPT：接受SNAT基于原地址的转换–to-source:指定源地址更多参数含义可以使用man命令查看。","path":"2018/11/15/iptables/","date":"11-15","excerpt":"","preview":"/imgs/preview/preview2.jpg"},{"title":"虚拟机杂谈","text":"虚拟机杂谈本文主要涉及到虚拟机的原理及概念，有时候并不会一步一步截图说明如何操作，建议多自己动手验证，将更有助于理解。 所以接下来的正如标题说，仅仅是个杂谈。（先别走啊！） 虽说是杂谈，但是后面还是会说到vmware组网中一些有趣的地方。算是对上一篇讲的网络原理的强化。 虚拟机的原理再次强调，这里的虚拟机原理仅仅是一个笼统的概念上的东西。那么开始吧。 虚拟机的大概结构如下： 网上一张很常见的图，被人贴了又贴。既然如此我也得贴上来。 但是我会讲解啊。 图上TYPE1被称为：裸机型即直接将虚拟机安装在硬件之上。这种虚拟机本身就是一个操作系统。（翻译： HARDWARE——硬件 TYPERVISOR——虚拟机监视器（虚拟化技术的核心，在裸机型中直接地调用硬件资源，可以看作是一个特殊的操作系统） OS———操作系统，即我们自己在虚拟机安装的操作系统） 使用这种技术的虚拟机有： Xen, Oracle VM Server for SPARC, Oracle VM Server for x86, Microsoft Hyper-V and VMware ESX/ESXi 这种虚拟机性能强，资源消耗小，资源控制能力强，兼容性高，总之十分可靠。就是配置比较复杂而且成本比较高。多用在企业。 TYPE2 则是宿主机型。这种类型的虚拟机必须将TYPERVISOR安装在操作系统之上，并构建一套虚拟硬件，即他们使用的硬件资源事实上是通过宿主机的操作系统来调用的。但是宿主机操作系统无疑是与虚拟机操作系统互不影响的。 这种虚拟机有：VMware Workstation, VMware Player, VirtualBox, Parallels Desktop for Mac and QEMU 事实上大部分人都是用的VMware，虽然他收费，但是有破解版。virtualBox开源，免费，虽然在性能确实比不上VMware，但是用的人也不少。 这种虚拟机虽然性能比不上裸机型，但是不花钱，配置简单，十分容易上手。已经足以满足大部分个人需求。 虚拟机的大概概念说完。接下来就是比较有趣的部分。 你真的知道虚拟机的三种网络连接方式的原理吗？VMware的三种网络连接方式VMware有三种联网模式，分别是桥接模式，NAT模式，以及仅主机模式。 他们使用各自虚拟出来的网卡在虚拟机下的虚拟网络编辑器下即可以看到： 桥接模式使用VMnet0,仅主机模式使用VMnet1,NAT模式使用VMnet8。 但是来看下这张图： 发现了吗，少了桥接模式的网卡VMnet0.VMnet0哪去了？继续往下看。 桥接模式桥接模式，看名字就知道，虚拟机通过网桥来连接网络。但具体怎么桥接呢？来看下面这张图。 左边的实线框是宿主机，右边的虚线框是虚拟机。 从图中可以很明显的看到，虚拟机在虚拟层模拟出一个VMware0网卡，这个网卡并不在宿主机内。网桥则从虚拟网卡桥接到物理网卡。也就是所有虚拟机系统连接在可以看作交换机的VMnet0网卡上，VMnet0网卡则与物理网卡桥接。 这就是宿主机上看不到VMnet0的原因。VMnet0实际上是在虚拟机内部的。 使用这个模式，虚拟机必须和宿主机处于同一个网段下。 这里可以通过配置静态路由或者DHCP即可实现 步骤如下（会的请直接跳过这里）：vim /etc/network/interfaces（这里需要注意一点：此命令是修改网卡配置文件，有些系统配置文件并不在这个目录下。） 进入vim编辑器后输入如下内容（如果不会用vim，需要查下vim的用法，这里不会对vim进行介绍）： 这里前面有#号的为注释掉的静态ip的配置方法，这里并不会启用。下面的白字则代表配置为DHCP模式。所以可以任选其一，注意如果使用静态IP要自己修改IP为与宿主机同一网段。 NAT模式这个模式也十分有意思。 当虚拟机设置为NAT模式，虚拟机与宿主机能够互相ping通。 看上去好像没什么毛病，似乎是理所当然的是吧。 但是，仔细想想，尼玛凭什么物理机能ping通虚拟机啊？这可是NAT模式啊！NAT模式！什么是NAT模式，路由器就是使用的NAT模式。在这个模式下，内网能主动ping通外网，但是外网无法ping通内网。在这里物理机即是外网，虚拟机则是内网。外网和内网之间需要一个NAT功能的路由器，而在这里充当路由器的并不是物理网卡。能看作路由的应该是虚拟机模拟出来的网卡。也就是说现在的情况相当与外网能直接ping通路由器下的内网主机！ 为什么呢，来看看下面的拓扑图： 这里可以看到虚拟机虚拟出了4样东西，其中有两个网卡。他们一个作为NAT设备，宿主机与虚拟机上都看不到这个网卡的存在。但是他作为虚拟机的网关，虚拟机与外界通信都要经由这里进行NAT转发。另一个网卡则是VMnet8,他存在于我们的宿主机上，与虚拟机的虚拟交换机相连。如果要实现NAT模式，那么一个NAT设备，一个DHCP服务器，一个虚拟机交换机，已经足够实现了。那么问题来了，要这个VMnet8何用，他即不是交换机也不是NAT设备。其实这个VMware8就是宿主机能ping通虚拟机的原因。如果禁用这个虚拟网卡，那么当宿主机发出ping请求的时候会直接发给网关，因为虚拟机与自己不在同一个网段下，而网关并不认识NAT网段，会直接丢掉。那么如果把虚拟机与宿主机放在同一个网段下呢？理论上物理网卡应该会进行ARP询问NAT设备的MAC，而NAT设备直连物理网卡，那么也会收到ARP报文。但是依然不行。虚拟机在NAT设备上限制了宿主机的访问。总之，当我们禁用这张VMnet8网卡后，宿主机将ping不通虚拟机，而虚拟机则不受影响。 可以看下面的验证过程：1.不禁用VMware8网卡：虚拟机与宿主机可以互相ping通 2.禁用VMware8网卡：虚拟机能ping通宿主机，宿主机ping不通虚拟机。同时虚拟机还能上网： 所以VMware8其实就算禁用掉也不影响虚拟机上网，只是宿主机不能直接ping虚拟机。所以结论就是VMnet8是宿主机主动与NAT虚拟机通信的链路！ 理解原理之后可以延伸出来一个实例问题：如果你有两台虚拟机，一台用桥接模式，一台用NAT模式。那么在不用SSH之类的任何内网穿透技术的情况下怎么样实现用桥接模式的虚拟机ping通NAT模式的虚拟机？ 在Linux下我们可以通过配置iptable来转发物理网卡上收到的发往NAT虚拟机的数据包。只要将数据包转发到VMnet8网卡就可以实现桥接的虚拟机ping通NAT的虚拟机。注意，这里如果转发到NAT网卡是不行的！ 如果在windows如何实现iptable功能呢？只需要将VMnet8网卡共享给物理网卡就可以了。（注意，这里是VMnet8共享Internet给物理网卡，而不是反过来！） 仅主机模式仅主机模式相当于去掉了NAT的NAT模式。他的拓扑图如下： 上图可以看到他少了NAT设备。缺少了NAT设备的结果就是不能连接外部网络，但是还可以和宿主机通信。如果要在仅主机模式下实现与外界通信也很简单，有点类似上面，只需要将物理网卡共享Internet给VMnet1就可以了（是物理网卡共享给VMnet1,。共享的方向是很重要的，意味着不同的包转发模式）。在理解了上面NAT模式的原理后，这里的原理自然也就知道了。","path":"2018/10/30/vmware/","date":"10-30","excerpt":"","preview":"/imgs/preview/preview3.jpg"},{"title":"你真的会配IP吗？","text":"提问：两个不同网段的主机直连能ping通吗？这么简单的问题还用问吗？答案当然是不能！ 好，那么本文到此就结束了，谢—–才怪！ 那么为什么不同网段就不能ping通呢，背后有着怎样的原理？在不加任何设备，不改IP的情况下有没有可能ping通？ 这就是写这篇文章的本意。通过一个简单的问题探寻IP及链路层的网络原理。 在windows的情况下很简单。怎么做呢？ 怎么可能这么快就说出来！ 之所以不说linux下也很简单是因为linux挖了一个坑，如果没留意可能会花不少时间。总之，本文目的在于让读者对底层的网络原理有更深的了解。能够应付大部分的网络疑难杂证。 现在要再次提问！网关和主机一定要在同一个网段吗？网关和主机之间可以间隔设备吗？通信过程中物理链路上到底发生了什么？直连的两台linux之间发生了什么？先来了解一下当ping命令发出时会发生些什么。 要深入理解这个问题，首先要搞清楚网络通讯的原理，网络上通讯工作在物理层和数据链路层，源地址和目标地址是通过源和目的的mac地址进行通讯的。当源主机访问目标主机时，首先看两者的IP在不在同一网段，结果是：1 两者在同一网段，就会直接把包发向目标IP，这时要做：1.1 查本地arp缓存，看看是否有IP和Mac的对应表：1.1.1 有，直接向链路上发包，包中包括原mac及目标mac。1.1.2 没有，则向网络发arp广播，用来查找与目标IP对应的mac地址（ARP发送的是广播数据，电缆上的每个以太网接口都要接收广播的数据帧，并且数据不会越过IP层，即所有的广播只会广播到与自己有物理链路直连，不跨设备的以太网接口上。（请不要拿交换机来抬杠，不接受抬杠！）而接受方收到之后会解包，将IP与自身拥有的IP对比，如果不是自己则丢弃，是则会根据包中的MAC地址发送arp相应包，由此告知对方自己的MAC地址）。1.1.2.1 如果查到了，则向网络发包。1.1.2.2 没查到，则不通讯。2 两者不在同一网段，则把目标地址转为网关地址（也就是向网关发包）2.1 查找本地arp缓存，看看是否有网关Mac2.1.1 有，向网关发送数据包2.1.2 没有，则向网络发送ARP广播，以获取路由表中指定的网关ip的MAC地址。2.1.2.1 找到，发包2.1.2.2 没找到，放弃由此可以看出，物理链路上的通信实际上是根据MAC地址来实现的。源主机寻找网关的过程中，并不会检查两者是不是同一网段，而是直接发送arp。网关需要与源主机有物理链路上的直连。 那么回到一开始的问题，AB两台直连的主机物理链路直连了就算网段不同也没理由不能通信。事实上从上面的描述已经很容易推出：当A向B发送数据包时，会先检验是否是同一个网段，而A和B不在同一个网段，所以会向网关发送这个数据包。如果AB之间有一台路由器，并且把网关设为路由器那么AB立马就能连通。而这里有个前提，不能加设备，不能改IP。这时候A和B之间只需要互指对方IP为网关就可以完成包的请求与回应了。（至于上面的几个简单问题，在理解这里后也很容易能推出来）结论已经出来了，在windows上确实可以直接简单互指网关进行通信。但是在linux上却有一个坑。 linux挖的坑假设A的ip是192.168.1.101,B的ip是192.168.2.102当两台linux以不同网段直连时，通过查看路由表route -n可以看到当前的路由表情况。如果你的linux是DHCP模式，你会发现他们的路由表都是只有一条，即本机的网段如：192.168.1.0 的下一跳指向0.0.0.0即他们都没有网关。 这时候可以尝试直接配路由表route add -net 192.168.2.0/24 gw 192.168.2.102 你会发现配不了，因为网关和本机不在同一个网段上 这时候呢需要用到下面这条命令ip route add 192.168.2.0/24 via 192.168.2.102 dev eth0 onlink这是新的iproute2下的命令，现在的linux一般都有iproute2包。其中via 代表下一跳 ， dev 代表使用 eth0 网卡 ，onlink是一个参数。onlink参数的作用：使用这个参数将会告诉内核，不必检查网关是否可达。因为在linux内核中，网关与本地的网段不同是被认为不可达的，从而拒绝执行添加路由的操作。 事实上，如果你配置静态IP就没这么多花里胡哨的事了。因为静态IP直接通过改文件来执行，并不会经过内核的检测。 一个有趣的延伸当你把A的IP改成 192.168.1.101/32 时，你无法通过任何正常的方法与其他主机通信，因为这里不属于任何网段，但是你可以通过上面的方式来进行物理链路上的直连。 什么？有什么用？ 「无可奉告」————长者","path":"2018/10/30/onlink/","date":"10-30","excerpt":"","preview":"/imgs/preview/preview1.jpg"},{"title":"用hexo搭建博客","text":"两天前想着是时候开始写个博客了，于是比较了一下现在的各种博客的平台，最后还是决定使用github+hexo组合来写自己的博客。 在搭建博客的过程中呢也是遇到了一点小麻烦，花了点时间。虽然本文也会涉及一点git和github，但是大概git和github的使用网上大多都比我详细且简单易懂吧，就着重写写hexo搭建博客的过程来当作第一篇博文吧。 Git与github的区别:git和github是两个不同的东西，因为两个经常一起使用，所以很容易有人搞混。事实上呢，git是一个管理代码的软件，而github则是一个网站。 前期准备：由于我使用的是linux系统，所以下面也是使用的linux系统 1.安装git和Node.js:git是一款能对代码进行，保存快照，版本更新，还原代码的软件，在代码开发里十分普及。Node.js则是运行javascript的必备环境，而javascript是接下来一定会用到的。打开终端先查看系统是否已经安装了git和node：12git --versionnode -v 如果出现了版本信息则是安装了，不过最好还是确认下有没有安装到最新版本：12apt-get install gitapt-get install nodejs 2.安装hexo:前两个安装好后就开始按照hexo：12sudo npm install -g hexosudo npm install hexo --save 此处的npm在nodejs安装包里包含 3.注册github:github页面虽然全是英文，但是也不算很难的单词。而且通过谷歌的页面翻译也可以很简单的注册。创建名为 用户名.github.io的存储库。进入仓库后在seting里配置github page，这就是网页名。如果仓库名不是上面的格式此处必须设置为上面的格式。 到此前期准备基本完成，开始来建立我们的博客 搭建博客通过hexo来建立一个博客模板：sudo hexo init blogblog为包名 进入blog目录cd blog 在blog目录中安装名为blognode_modules的依赖项。npm install 到此处，博客模板已经搭建完 可以先在本地尝试浏览一下博客页面hexo server然后在浏览器里访问 127.0.0.1:4000就可以看到博客页面了。 将博客放到网页上打开blog目录下的_config.yml文件拉到末尾在deploy那里修改成下面这个样子1234deploy: type: git repository: https://github.com/用户名/用户名.github.io.git branch: master 然后执行下列命令12hexo g #生成博客页面hexo d #发布到github 输入用户名及密码之后就发布成功了 ##修改主题 主题可以在hexo官网里找具体的修改方法主题的发布作者一般会作说明，这里不再赘述。那么本文就到此为止了","path":"2018/10/29/hexo/","date":"10-29","excerpt":"","preview":"/imgs/preview/preview6.jpg"}]}