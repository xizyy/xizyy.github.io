{"pages":[{"title":"就这么几篇你还要分类？？？","text":"","path":"categories/index.html","date":"10-28","excerpt":""},{"title":"标签有什么好看的","text":"","path":"tags/index.html","date":"10-28","excerpt":""},{"title":"萌新一个","text":"","path":"about/index.html","date":"10-28","excerpt":""},{"title":"search","text":"","path":"search/index.html","date":"10-28","excerpt":""},{"title":"404","text":"","path":"404/index.html","date":"10-28","excerpt":""}],"posts":[{"title":"虚拟机杂谈","text":"虚拟机杂谈本文主要涉及到虚拟机的原理及概念，有时候并不会一步一步截图说明如何操作，建议多自己动手验证，将更有助于理解。 所以接下来的正如标题说，仅仅是个杂谈。（先别走啊！） 虽说是杂谈，但是后面还是会说到vmware组网中一些有趣的地方。算是对上一篇讲的网络原理的强化。 虚拟机的原理再次强调，这里的虚拟机原理仅仅是一个笼统的概念上的东西。那么开始吧。 虚拟机的大概结构如下： 网上一张很常见的图，被人贴了又贴。既然如此我也得贴上来。 但是我会讲解啊。 图上TYPE1被称为：裸机型即直接将虚拟机安装在硬件之上。这种虚拟机本身就是一个操作系统。（翻译： HARDWARE——硬件 TYPERVISOR——虚拟机监视器（虚拟化技术的核心，在裸机型中直接地调用硬件资源，可以看作是一个特殊的操作系统） OS———操作系统，即我们自己在虚拟机安装的操作系统） 使用这种技术的虚拟机有： Xen, Oracle VM Server for SPARC, Oracle VM Server for x86, Microsoft Hyper-V and VMware ESX/ESXi 这种虚拟机性能强，资源消耗小，资源控制能力强，兼容性高，总之十分可靠。就是配置比较复杂而且成本比较高。多用在企业。 TYPE2 则是宿主机型。这种类型的虚拟机必须将TYPERVISOR安装在操作系统之上，并构建一套虚拟硬件，即他们使用的硬件资源事实上是通过宿主机的操作系统来调用的。但是宿主机操作系统无疑是与虚拟机操作系统互不影响的。 这种虚拟机有：VMware Workstation, VMware Player, VirtualBox, Parallels Desktop for Mac and QEMU 事实上大部分人都是用的VMware，虽然他收费，但是有破解版。virtualBox开源，免费，虽然在性能确实比不上VMware，但是用的人也不少。 这种虚拟机虽然性能比不上裸机型，但是不花钱，配置简单，十分容易上手。已经足以满足大部分个人需求。 虚拟机的大概概念说完。接下来就是比较有趣的部分。 你真的知道虚拟机的三种网络连接方式的原理吗？VMware的三种网络连接方式VMware有三种联网模式，分别是桥接模式，NAT模式，以及仅主机模式。 他们使用各自虚拟出来的网卡在虚拟机下的虚拟网络编辑器下即可以看到： 桥接模式使用VMnet0,仅主机模式使用VMnet1,NAT模式使用VMnet8。 但是来看下这张图： 发现了吗，少了桥接模式的网卡VMnet0.VMnet0哪去了？继续往下看。 桥接模式桥接模式，看名字就知道，虚拟机通过网桥来连接网络。但具体怎么桥接呢？来看下面这张图。 左边的实线框是宿主机，右边的虚线框是虚拟机。 从图中可以很明显的看到，虚拟机在虚拟层模拟出一个VMware0网卡，这个网卡并不在宿主机内。网桥则从虚拟网卡桥接到物理网卡。也就是所有虚拟机系统连接在可以看作交换机的VMnet0网卡上，VMnet0网卡则与物理网卡桥接。 这就是宿主机上看不到VMnet0的原因。VMnet0实际上是在虚拟机内部的。 使用这个模式，虚拟机必须和宿主机处于同一个网段下。 这里可以通过配置静态路由或者DHCP即可实现 步骤如下（会的请直接跳过这里）：vim /etc/network/interfaces（这里需要注意一点：此命令是修改网卡配置文件，有些系统配置文件并不在这个目录下。） 进入vim编辑器后输入如下内容（如果不会用vim，需要查下vim的用法，这里不会对vim进行介绍）： 这里前面有#号的为注释掉的静态ip的配置方法，这里并不会启用。下面的白字则代表配置为DHCP模式。所以可以任选其一，注意如果使用静态IP要自己修改IP为与宿主机同一网段。 NAT模式这个模式也十分有意思。 当虚拟机设置为NAT模式，虚拟机与宿主机能够互相ping通。 看上去好像没什么毛病，似乎是理所当然的是吧。 但是，仔细想想，尼玛凭什么物理机能ping通虚拟机啊？这可是NAT模式啊！NAT模式！什么是NAT模式，路由器就是使用的NAT模式。在这个模式下，内网能主动ping通外网，但是外网无法ping通内网。在这里物理机即是外网，虚拟机则是内网。外网和内网之间需要一个NAT功能的路由器，而在这里充当路由器的并不是物理网卡。能看作路由的应该是虚拟机模拟出来的网卡。也就是说现在的情况相当与外网能直接ping通路由器下的内网主机！ 为什么呢，来看看下面的拓扑图： 这里可以看到虚拟机虚拟出了4样东西，其中有两个网卡。他们一个作为NAT设备，宿主机与虚拟机上都看不到这个网卡的存在。但是他作为虚拟机的网关，虚拟机与外界通信都要经由这里进行NAT转发。另一个网卡则是VMnet8,他存在于我们的宿主机上，与虚拟机的虚拟交换机相连。如果要实现NAT模式，那么一个NAT设备，一个DHCP服务器，一个虚拟机交换机，已经足够实现了。那么问题来了，要这个VMnet8何用，他即不是交换机也不是NAT设备。其实这个VMware8就是宿主机能ping通虚拟机的原因。如果禁用这个虚拟网卡，那么当宿主机发出ping请求的时候会直接发给网关，因为虚拟机与自己不在同一个网段下，而网关并不认识NAT网段，会直接丢掉。那么如果把虚拟机与宿主机放在同一个网段下呢？理论上物理网卡应该会进行ARP询问NAT设备的MAC，而NAT设备直连物理网卡，那么也会收到ARP报文。但是依然不行。虚拟机在NAT设备上限制了宿主机的访问。总之，当我们禁用这张VMnet8网卡后，宿主机将ping不通虚拟机，而虚拟机则不受影响。 可以看下面的验证过程：1.不禁用VMware8网卡：虚拟机与宿主机可以互相ping通 2.禁用VMware8网卡：虚拟机能ping通宿主机，宿主机ping不通虚拟机。同时虚拟机还能上网： 所以VMware8其实就算禁用掉也不影响虚拟机上网，只是宿主机不能直接ping虚拟机。所以结论就是VMnet8是宿主机主动与NAT虚拟机通信的链路！ 理解原理之后可以延伸出来一个实例问题：如果你有两台虚拟机，一台用桥接模式，一台用NAT模式。那么在不用SSH之类的任何内网穿透技术的情况下怎么样实现用桥接模式的虚拟机ping通NAT模式的虚拟机？ 在Linux下我们可以通过配置iptable来转发物理网卡上收到的发往NAT虚拟机的数据包。只要将数据包转发到VMnet8网卡就可以实现桥接的虚拟机ping通NAT的虚拟机。注意，这里如果转发到NAT网卡是不行的！ 如果在windows如何实现iptable功能呢？只需要将VMnet8网卡共享给物理网卡就可以了。（注意，这里是VMnet8共享Internet给物理网卡，而不是反过来！） 仅主机模式仅主机模式相当于去掉了NAT的NAT模式。他的拓扑图如下： 上图可以看到他少了NAT设备。缺少了NAT设备的结果就是不能连接外部网络，但是还可以和宿主机通信。如果要在仅主机模式下实现与外界通信也很简单，有点类似上面，只需要将物理网卡共享Internet给VMnet1就可以了（是物理网卡共享给VMnet1,。共享的方向是很重要的，意味着不同的包转发模式）。在理解了上面NAT模式的原理后，这里的原理自然也就知道了。","path":"2018/10/30/vmware/","date":"10-30","excerpt":""},{"title":"你真的会配IP吗？","text":"提问：两个不同网段的主机直连能ping通吗？这么简单的问题还用问吗？答案当然是不能！ 好，那么本文到此就结束了，谢—–才怪！ 在不加任何设备，不改IP的情况下有没有可能ping通？ 当然有，这就是这篇文章存在的原因。在windows的情况下很简单。怎么做呢？ 怎么可能这么快就说出来！ 本文主要探讨的是linux的情况下如何做。并且目的在于让读者对底层的网络原理有更深的了解。能够应付大部分的网络疑难杂证。 现在要再次提问！网关和主机一定要在同一个网段吗？网关和主机之间可以间隔设备吗？通信过程中物理链路上到底发生了什么？直连的两台linux之间发生了什么？先来了解一下当ping命令发出时会发生些什么。 要深入理解这个问题，首先要搞清楚网络通讯的原理，网络上通讯工作在物理层和数据链路层，源地址和目标地址是通过源和目的的mac地址进行通讯的。当源主机访问目标主机时，首先看两者的IP在不在同一网段，结果是：1 两者在同一网段，就会直接把包发向目标IP，这时要做：1.1 查本地arp缓存，看看是否有IP和Mac的对应表：1.1.1 有，直接向链路上发包，包中包括原mac及目标mac。1.1.2 没有，则向网络发arp广播，用来查找与目标IP对应的mac地址（ARP发送的是广播数据，电缆上的每个以太网接口都要接收广播的数据帧，并且数据不会越过IP层，即所有的广播只会广播到与自己有物理链路直连，不跨设备的以太网接口上。（请不要拿交换机来抬杠，不接受抬杠！）而接受方收到之后会解包，将IP与自身拥有的IP对比，如果不是自己则丢弃，是则会根据包中的MAC地址发送arp相应包，由此告知对方自己的MAC地址）。1.1.2.1 如果查到了，则向网络发包。1.1.2.2 没查到，则不通讯。2 两者不在同一网段，则把目标地址转为网关地址（也就是向网关发包）2.1 查找本地arp缓存，看看是否有网关Mac2.1.1 有，向网关发送数据包2.1.2 没有，则向网络发送ARP广播，以获取路由表中指定的网关ip的MAC地址。2.1.2.1 找到，发包2.1.2.2 没找到，放弃由此可以看出，物理链路上的通信实际上是根据MAC地址来实现的。源主机寻找网关的过程中，并不会检查两者是不是同一网段，而是直接发送arp。网关需要与源主机有物理链路上的直连。 那么两台直连的liunx物理链路都连上了凭什么不能通信。事实上从上面的描述已经很容易推出，A和B之间只需要互指对方IP为网关就可以通信了。 结论基本已经出来了，在windows上确实可以直接简单互指网关进行通信。但是在linux上却有一个坑。 linux挖的坑假设A的ip是192.168.1.101,B的ip是192.168.2.102当两台linux以不同网段直连时，通过查看路由表route -n可以看到当前的路由表情况。如果你的linux是DHCP模式，你会发现他们的路由表都是只有一条，即本机的网段如：192.168.1.0 的下一跳指向0.0.0.0即他们都没有网关。 这时候可以尝试直接配路由表route add -net 192.168.2.0/24 gw 192.168.2.102 你会发现配不了，因为网关和本机不在同一个网段上 这时候呢需要用到下面这条命令ip route add 192.168.2.0/24 via 192.168.2.102 dev eth0 onlink这是新的iproute2下的命令，现在的linux一般都有iproute2包。其中via 代表下一跳 ， dev 代表使用 eth0 网卡 ，onlink是一个参数。onlink参数的作用：使用这个参数将会告诉内核，不必检查网关是否可达。因为在linux内核中，网关与本地的网段不同是被认为不可达的，从而拒绝执行添加路由的操作。 事实上，如果你配置静态IP就没这么多花里胡哨的事了。因为静态IP直接通过改文件来执行，并不会经过内核的检测。 一个有趣的延伸当你把A的IP改成 192.168.1.101/32 时，你无法通过任何正常的方法与其他主机通信，因为这里不属于任何网段，但是你可以通过上面的方式来进行物理链路上的直连。 什么？有什么用？ 「无可奉告」————长者","path":"2018/10/30/onlink/","date":"10-30","excerpt":""},{"title":"用hexo搭建博客","text":"两天前想着是时候开始写个博客了，于是比较了一下现在的各种博客的平台，最后还是决定使用github+hexo组合来写自己的博客。 在搭建博客的过程中呢也是遇到了一点小麻烦，花了点时间。虽然本文也会涉及一点git和github，但是大概git和github的使用网上大多都比我详细且简单易懂吧，就着重写写hexo搭建博客的过程来当作第一篇博文吧。 Git与github的区别:git和github是两个不同的东西，因为两个经常一起使用，所以很容易有人搞混。事实上呢，git是一个管理代码的软件，而github则是一个网站。 前期准备：由于我使用的是linux系统，所以下面也是使用的linux系统 1.安装git和Node.js:git是一款能对代码进行，保存快照，版本更新，还原代码的软件，在代码开发里十分普及。Node.js则是运行javascript的必备环境，而javascript是接下来一定会用到的。打开终端先查看系统是否已经安装了git和node：12git --versionnode -v 如果出现了版本信息则是安装了，不过最好还是确认下有没有安装到最新版本：12apt-get install gitapt-get install nodejs 2.安装hexo:前两个安装好后就开始按照hexo：12sudo npm install -g hexosudo npm install hexo --save 此处的npm在nodejs安装包里包含 3.注册github:github页面虽然全是英文，但是也不算很难的单词。而且通过谷歌的页面翻译也可以很简单的注册。创建名为 用户名.github.io的存储库。进入仓库后在seting里配置github page，这就是网页名。如果仓库名不是上面的格式此处必须设置为上面的格式。 到此前期准备基本完成，开始来建立我们的博客 搭建博客通过hexo来建立一个博客模板：sudo hexo init blogblog为包名 进入blog目录cd blog 在blog目录中安装名为blognode_modules的依赖项。npm install 到此处，博客模板已经搭建完 可以先在本地尝试浏览一下博客页面hexo server然后在浏览器里访问 127.0.0.1:4000就可以看到博客页面了。 将博客放到网页上打开blog目录下的_config.yml文件拉到末尾在deploy那里修改成下面这个样子1234deploy: type: git repository: https://github.com/用户名/用户名.github.io.git branch: master 然后执行下列命令12hexo g #生成博客页面hexo d #发布到github 输入用户名及密码之后就发布成功了 ##修改主题 主题可以在hexo官网里找具体的修改方法主题的发布作者一般会作说明，这里不再赘述。那么本文就到此为止了","path":"2018/10/29/hexo/","date":"10-29","excerpt":""}]}